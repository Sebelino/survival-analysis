---
title: "Survival Analysis: Take-home Exam"
output:
  prettydoc::html_pretty:
    theme: cayman
    highlight: github
---

# AI disclosure

ChatGPT was used to review my solutions and for grammar and clarity checks.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, comment = "")
```

# A.1.

Let \(\lambda_1 = \lambda\exp(\beta x)\).
Then the proportional hazards model has a survival time function
of the form:

\begin{align*}
    & S(t|x) \\
    =& S_0(t)^{\exp(\beta x)} \\
    =& \exp(-\lambda t^k)^{\exp(\beta x)} \\
    =& \exp(-\lambda t^k\exp(\beta x)) \\
    =& \exp(-\lambda\exp(\beta x) t^k) \\
    =& \exp(-\lambda_1 t^k) \\
\end{align*}

which has the form of a Weibull distribution
with shape parameter $k$ and scale parameter
\(\lambda_1 = \lambda\exp(-k\tilde{\beta} x)\).

# A.2.

Let \(\lambda_2 = \lambda\exp(-k\tilde{\beta} x)\).
Then the accelerated survival time model has a survival time function
of the form:

\begin{align*}
    & S(t|x) \\
    =& S_0(t \exp(-\tilde{\beta} x)) \\
    =& \exp(-\lambda(t \exp(-\tilde{\beta} x))^k) \\
    =& \exp(-\lambda t^k \exp(-\tilde{\beta} x)^k) \\
    =& \exp(-\lambda t^k \exp(-k\tilde{\beta} x)) \\
    =& \exp(-\lambda\exp(-k\tilde{\beta} x) t^k) \\
    =& \exp(-\lambda_2 t^k ) \\
\end{align*}

which has the form of a Weibull distribution
with shape parameter $k$ and scale parameter
\(\lambda_2 = \lambda\exp(-k\tilde{\beta} x)\).

# A.3.

Proportional hazards model survival function:
\[\exp(-\lambda\exp(\beta x) t^k)\]
Accelerated survival time model survival function:
\[\exp(-\lambda\exp(-k\tilde{\beta} x) t^k)\]
We see that the survival functions are equal if
the log hazard ratio is related to the log time ratio like so:
\[\beta = -k\tilde{\beta}\]
Given that the shape parameter \(k\) is positive,
this means
a positive \(\beta\) implies a negative \(\tilde{\beta}\).

# B.1.

Let \(T\) be the survival time of an individual,
so that \(S(t) = P(T>t)\).

## a)

For individual \(i\),
we know that the event was observed in the interval \((u_i,v_i]\),
which means \(u_i < T_i \leq v_i\). Furthermore,
the event is only observed if \(T_i > t_i\), so we need to
condition on \(T_i>t_i\).
The likelihood contribution for a single data tuple \((t_i,u_i,v_i)\) is:
\begin{align*}
    & P(u_i < T_i \leq v_i \, | \, T_i > t_i) \\
    =& \frac{P(\{u_i < T_i \leq v_i\} \cap \{T_i > t_i\})}{P(T_i > t_i)} \\
    =& \frac{P(\max(t_i,u_i) < T_i \leq v_i)}{P(T_i > t_i)} \\
    =& \frac{P(u_i < T_i \leq v_i)}{P(T_i > t_i)} \\
    =& \frac{F_{T_i}(v_i)-F_{T_i}(u_i)}{P(T_i > t_i)} \\
    =& \frac{1-S(v_i)-(1-S(u_i))}{S(t_i)} \\
    =& \frac{S(u_i)-S(v_i)}{S(t_i)} \\
\end{align*}

Log-likelihood contribution for individual \(i\):
\begin{align*}
    & \ell_i \\
    =& \ln\frac{S(u_i)-S(v_i)}{S(t_i)} \\
    =& \ln(S(u_i) - S(v_i)) - \ln S(t_i) \\
\end{align*}

Log-likelihood contribution for \(n\) individuals:
\begin{align*}
    & \ell_{1:n} \\
    =& \ln\prod_{i=1}^n \frac{S(u_i)-S(v_i)}{S(t_i)} \\
    =& \sum_{i=1}^n \left(\ln(S(u_i) - S(v_i)) - \ln S(t_i)\right) \\
\end{align*}

## b)

Log-likelihood contribution for individual \(i\):
\begin{align*}
    & \ell_i \\
    =& \ln(S(u_i) - S(v_i)) - \ln S(t_i) \\
    =& \ln\left(S(u_i) - S(u_i)\exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right) - \ln S(t_i) \\
    =& \ln\left(S(u_i)\left(1 - \exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right)\right) - \ln S(t_i) \\
    =& \ln S(u_i) + \ln\left(1 - \exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right) - \ln S(t_i) \\
    =& \ln \exp\left(-\int_0^{u_i} h(t)dt\right) + \ln\left(1 - \exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right) - \ln \exp\left(-\int_0^{t_i} h(t)dt\right) \\
    =& -\int_0^{u_i} h(t)dt + \ln\left(1 - \exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right) +\int_0^{t_i} h(t)dt \\
    =& \ln\left(1 - \exp\left(-\int_{u_i}^{v_i} h(t)dt\right)\right) - \int_{t_i}^{u_i} h(t)dt
\end{align*}

<!-- TODO n individuals case as well? -->

# B.2.

```{r, message=FALSE, echo=FALSE}
library(survival)
```

According to the documentation [REF] and source code [REF]
for version `3.8-3` of the package,
the function takes the following arguments:

* `time`: Number.
* `time2`: Number.
* `event`: Either 0, 1, 2, 3, TRUE or FALSE.
* `type`: Any of the strings: `'right'`, `'left'`, `'interval'`, `'counting'`, `'interval2'`, `'mstate'`.
* `origin`: Number.

Let us assume that it is possible to express the tuple \((t_i,u_i,v_i)\)
using the `Surv` function.
Then it is possible to do so by
a function call of the form:
```{r, eval=FALSE}
Surv(time=a, time2=b, event=c, type=d, origin=e)
```
Since $t_i$, $u_i$, and $v_i$ are arbitrary numbers,
we cannot pass them to the function via the `event` or `type` arguments.
Hence, $t_i$, $u_i$, and $v_i$
can only be passed to the function using the
`time`, `time2`, and `origin` arguments.

Further, it is reasonable to presume that
$t_i$, $u_i$, and $v_i$ are passed to the function
via the `time`, `time2`, and `origin` arguments in a bijective manner.
That is, the `Surv` function is not implemented in a way such that,
for example, the data contained in the $t_i$ and $u_i$ values are cleverly encoded together so they can be passed using a single argument, e.g. `time`.

However, according to the documentation and source code,
the `origin` argument simply shifts the time scale,
by subtracting from `time` and `time2`.
Left truncation requires `type='counting'` which
does not allow for interval censoring.
On the other hand, interval censoring requires `type='interval'`
which does not allow for left truncation.
It is therefore not possible to use this argument to pass
information regarding left truncation or interval censoring.

Hence, we are left with only two arguments: `time` and `time2`
for passing the three values.
By the pigeonhole principle,
it is not possible to pass three values using only two arguments.
Thus, our initial assumption is incorrect.
It is not possible to express the tuple \((t_i,u_i,v_i)\)
using the `Surv` function.

# C.1.

# C.2.

# C.3.

# C.4.

# D.1.

# D.2.

# D.3.

# D.4.

# E.1.

# E.2.

# E.3.

# E.4.

# F.1.

# F.2.


```{r, message=FALSE}
library(biostat3) # colon
library(dplyr)
```
